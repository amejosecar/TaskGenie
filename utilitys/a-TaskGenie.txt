----------------------------------------
# C:\americo\API\TaskGenie\.env
# Archivo de configuración de variables sensibles.
DATABASE_URL=sqlite:///./taskgenie.db
SECRET_KEY=tu_clave_secreta
DEBUG_MODE=True

----------------------------------------
# C:\americo\API\TaskGenie\auth.py
# auth.py (ubicado en C:\americo\API\TaskGenie\auth.py)
# 

from fastapi import APIRouter, Depends, Form, HTTPException, status, Request, Body
from fastapi.responses import JSONResponse, HTMLResponse, RedirectResponse
from sqlalchemy.orm import Session
from pydantic import BaseModel
from database import SessionLocal, Usuario
from services.auth_service import registrar_usuario, autenticar_usuario
from fastapi.templating import Jinja2Templates

router = APIRouter()
templates = Jinja2Templates(directory="templates")

# Dependencia para obtener la sesión de la base de datos.
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# =========================== Endpoints JSON ===========================
class UsuarioCreate(BaseModel):
    nombre: str
    apellido: str
    edad: int
    fecha_nacimiento: str  # Formato YYYY-MM-DD
    email: str
    clave: str
    rol: str

class UsuarioLogin(BaseModel):
    email: str
    clave: str

@router.post("/api/registro", response_model=dict)
def registrar_usuario_json(usuario: UsuarioCreate, db: Session = Depends(get_db)):
    try:
        nuevo_usuario = registrar_usuario(
            db,
            nombre=usuario.nombre,
            apellido=usuario.apellido,
            edad=usuario.edad,
            fecha_nacimiento=usuario.fecha_nacimiento,
            email=usuario.email,
            rol=usuario.rol,
            clave=usuario.clave
            
        )
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=str(e)
        )
    return {"mensaje": "Usuario registrado correctamente (JSON)", "id": nuevo_usuario.id}

@router.post("/api/login", response_model=dict)
def login_json(usuario: UsuarioLogin, db: Session = Depends(get_db)):
    usuario_db = autenticar_usuario(db, email=usuario.email, clave=usuario.clave)
    if not usuario_db:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales inválidas."
        )
    return {"mensaje": "Login exitoso (JSON)", "usuario_id": usuario_db.id}

# ======================== Endpoints para Formularios HTML =======================
@router.get("/registro", response_class=HTMLResponse)
def registro_form_get(request: Request):
    return templates.TemplateResponse("registro.html", {"request": request})


@router.post("/registro_form")
def registrar_usuario_form(
    nombre: str = Form(...),
    apellido: str = Form(...),
    edad: int = Form(...),
    fecha_nacimiento: str = Form(...),  # Formato YYYY-MM-DD
    email: str = Form(...),
    rol: str = Form(...),
    clave: str = Form(...),
    db: Session = Depends(get_db)
):
    try:
        nuevo_usuario = registrar_usuario(
            db,
            nombre=nombre,
            apellido=apellido,
            edad=edad,
            fecha_nacimiento=fecha_nacimiento,
            email=email,
            rol=rol,
            clave=clave
        )
    except ValueError as e:
        return templates.TemplateResponse("registro.html", {"request": {}, "error": str(e)})
    return RedirectResponse(url="/login", status_code=status.HTTP_302_FOUND)


@router.get("/login", response_class=HTMLResponse)
def login_form_get(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})


@router.post("/login_form")
def login_form(
    email: str = Form(...),
    clave: str = Form(...),
    db: Session = Depends(get_db)
):
    db_usuario = autenticar_usuario(db, email=email, clave=clave)
    if not db_usuario:
        return templates.TemplateResponse("index.html", {"request": {}, "error": "Credenciales inválidas."})
    
    # Verificar el rol y redireccionar según corresponda:
    if db_usuario.rol == "Administrador":
        # Redirigir a la ruta definida, NO a la carpeta de templates.
        return RedirectResponse(url="/dashboard_admin", status_code=status.HTTP_302_FOUND)
    else:
        return RedirectResponse(url="/dashboard", status_code=status.HTTP_302_FOUND)



# ================= Endpoint Alternativo para Pruebas en Swagger =================
# Este endpoint usa Body y un modelo JSON, por lo que Swagger mostrará los parámetros.
class UsuarioForm(BaseModel):
    nombre: str
    apellido: str
    edad: int
    fecha_nacimiento: str  # YYYY-MM-DD
    email: str
    clave: str
    rol: str

@router.post("/registro_form_alt")
def registrar_usuario_form_alt(form: UsuarioForm = Body(...), db: Session = Depends(get_db)):
    try:
        nuevo_usuario = registrar_usuario(
            db,
            nombre=form.nombre,
            apellido=form.apellido,
            edad=form.edad,
            fecha_nacimiento=form.fecha_nacimiento,
            email=form.email,
            rol=form.rol,
            clave=form.clave
            
        )
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    return {"mensaje": "Usuario registrado correctamente (Form Alternative)", "id": nuevo_usuario.id}

----------------------------------------
# C:\americo\API\TaskGenie\config.py
# congig.py
# # Manejo de variables de entorno.
import os
from dotenv import load_dotenv

load_dotenv()

class Settings:
    DATABASE_URL: str = os.getenv("DATABASE_URL")
    SECRET_KEY: str = os.getenv("SECRET_KEY")
    DEBUG_MODE: bool = os.getenv("DEBUG_MODE", "False").lower() == "true"

settings = Settings()

----------------------------------------
# C:\americo\API\TaskGenie\database.py
# database.py
# Configuración de la conexión a SQLite.
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = "sqlite:///./taskgenie.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

# Modelo de Usuario
class Usuario(Base):
    __tablename__ = "usuarios"
    id = Column(Integer, primary_key=True, index=True)
    nombre = Column(String, nullable=False)
    apellido = Column(String, nullable=False)
    edad = Column(Integer, nullable=False)
    fecha_nacimiento = Column(String, nullable=False)  # Formato YYYY-MM-DD
    email = Column(String, unique=True, nullable=False)
    rol = Column(String, nullable=False)  # Por ejemplo: 'admin', 'usuario', etc.
    # En producción se debería almacenar la contraseña como hash
    clave = Column(String, nullable=False)  

# Crear tablas en la BD
Base.metadata.create_all(bind=engine)


----------------------------------------
# C:\americo\API\TaskGenie\main.py
# main.py - Punto de arranque de la aplicación.

from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse, HTMLResponse
from fastapi.templating import Jinja2Templates

from auth import router as auth_router
from routers import tareas, perfil, admin  # Asegúrate de que admin se importe
# resto de importaciones...

app = FastAPI(title="TaskGenie")
templates = Jinja2Templates(directory="templates")

app.include_router(auth_router, tags=["Autenticación"])
app.include_router(tareas.router, prefix="/tareas", tags=["Tareas"])
app.include_router(perfil.router, prefix="/perfil", tags=["Perfil"])
app.include_router(admin.router, prefix="/admin", tags=["Administración"])  # Nuevo router admin

@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request):
    return templates.TemplateResponse("dashboard.html", {"request": request})

@app.exception_handler(404)
async def not_found_exception_handler(request: Request, exc: HTTPException):
    accept = request.headers.get("accept", "")
    if "text/html" in accept:
        return templates.TemplateResponse(
            "errores.html",
            {"request": request, "mensaje": "La página que buscas no fue encontrada. Por favor, revisa la URL o regresa al inicio."},
            status_code=404
        )
    return JSONResponse(status_code=404, content={"detail": "La página no fue encontrada."})

@app.get("/dashboard_admin", response_class=HTMLResponse)
async def dashboard_admin(request: Request):
    return templates.TemplateResponse("dashboard_admin.html", {"request": request})


----------------------------------------
# C:\americo\API\TaskGenie\models.py
# models.py
# Modelos de SQLAlchemy.

from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Date, Enum, Boolean, ForeignKey
from sqlalchemy.orm import relationship
import enum

Base = declarative_base()

class RolEnum(enum.Enum):
    profesor = "profesor"
    alumno = "alumno"
    administrador = "administrador"

class Usuario(Base):
    __tablename__ = "usuarios"
    id = Column(Integer, primary_key=True, index=True)
    nombre = Column(String, nullable=False)
    apellido = Column(String, nullable=False)
    email = Column(String, unique=True, nullable=False)
    clave = Column(String, nullable=False)  # Se recomienda utilizar hash en producción
    fecha_nacimiento = Column(Date)
    rol = Column(Enum(RolEnum), nullable=False)
    bloqueado = Column(Boolean, default=False)  # Nuevo campo: estado de bloqueo

    # Relaciones con tareas:
    tareas_creadas = relationship("Tarea", back_populates="creador", foreign_keys="Tarea.creador_id")
    tareas_asignadas = relationship("Tarea", back_populates="asignado", foreign_keys="Tarea.asignado_a")

class Tarea(Base):
    __tablename__ = "tareas"
    id = Column(Integer, primary_key=True, index=True)
    titulo = Column(String, nullable=False)
    descripcion = Column(String)
    importancia = Column(String)
    fecha_entrega = Column(Date)
    estado = Column(String, default="asignada")
    solucion = Column(String)  # Opcional

    creador_id = Column(Integer, ForeignKey("usuarios.id"))
    asignado_a = Column(Integer, ForeignKey("usuarios.id"))

    creador = relationship("Usuario", back_populates="tareas_creadas", foreign_keys=[creador_id])
    asignado = relationship("Usuario", back_populates="tareas_asignadas", foreign_keys=[asignado_a])

----------------------------------------
# C:\americo\API\TaskGenie\requirements.txt
# Error al leer este archivo: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

----------------------------------------
# C:\americo\API\TaskGenie\schemas.py
#  schemas.py
# Schemas con Pydantic.
from pydantic import BaseModel, EmailStr
from datetime import date
from enum import Enum

class RolEnum(str, Enum):
    profesor = "profesor"
    alumno = "alumno"
    administrador = "administrador"

class UsuarioCreate(BaseModel):
    nombre: str
    apellido: str
    email: EmailStr
    clave: str
    fecha_nacimiento: date
    rol: RolEnum

class UsuarioResponse(BaseModel):
    id: int
    nombre: str
    apellido: str
    email: EmailStr
    fecha_nacimiento: date
    rol: RolEnum

    class Config:
        orm_mode = True

# Esquema para actualizar rol.
class UsuarioUpdateRol(BaseModel):
    rol: RolEnum

# Esquema para actualizar estado de bloqueo.
class UsuarioUpdateBloqueo(BaseModel):
    bloqueado: bool



class MensajeResponse(BaseModel):
    mensaje: str


----------------------------------------
# C:\americo\API\TaskGenie\taskgenie.db
# Error al leer este archivo: 'utf-8' codec can't decode byte 0x86 in position 98: invalid start byte

----------------------------------------
# C:\americo\API\TaskGenie\__init__.py

----------------------------------------
# C:\americo\API\TaskGenie\routers\admin.py
# # Endpoints para administración de usuarios.
# # routers/admin.py
# 
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Optional
from database import SessionLocal, Usuario
from schemas import (
    UsuarioResponse,
    UsuarioUpdateRol,
    UsuarioUpdateBloqueo,
    MensajeResponse
)

router = APIRouter()

# Dependencia para obtener la sesión de la base de datos.
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Endpoint 1: Listar todos los usuarios
@router.get("/usuarios", response_model=List[UsuarioResponse])
def listar_usuarios(db: Session = Depends(get_db)):
    usuarios = db.query(Usuario).all()
    return usuarios

# Endpoint 2: Obtener el detalle de un usuario específico
@router.get("/usuarios/{user_id}", response_model=UsuarioResponse)
def obtener_detalle_usuario(user_id: int, db: Session = Depends(get_db)):
    usuario = db.query(Usuario).filter(Usuario.id == user_id).first()
    if not usuario:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Usuario no encontrado"
        )
    return usuario

# Endpoint 3: Actualizar el rol de un usuario
@router.put("/usuarios/{user_id}/rol", response_model=UsuarioResponse)
def actualizar_rol(user_id: int, update: UsuarioUpdateRol, db: Session = Depends(get_db)):
    usuario = db.query(Usuario).filter(Usuario.id == user_id).first()
    if not usuario:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Usuario no encontrado"
        )
    usuario.rol = update.rol
    db.commit()
    db.refresh(usuario)
    return usuario

# Endpoint 4: Actualizar el estado de bloqueo de un usuario
@router.put("/usuarios/{user_id}/bloqueo", response_model=UsuarioResponse)
def actualizar_bloqueo(user_id: int, update: UsuarioUpdateBloqueo, db: Session = Depends(get_db)):
    usuario = db.query(Usuario).filter(Usuario.id == user_id).first()
    if not usuario:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Usuario no encontrado"
        )
    usuario.bloqueado = update.bloqueado
    db.commit()
    db.refresh(usuario)
    return usuario

# Endpoint 5 (Opcional): Eliminar un usuario
@router.delete("/usuarios/{user_id}", response_model=MensajeResponse)
def eliminar_usuario(user_id: int, db: Session = Depends(get_db)):
    usuario = db.query(Usuario).filter(Usuario.id == user_id).first()
    if not usuario:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Usuario no encontrado"
        )
    db.delete(usuario)
    db.commit()
    return {"mensaje": "Usuario eliminado con éxito"}

# (Opcional) Endpoint Extra: Buscar usuarios por filtro
@router.get("/usuarios/search", response_model=List[UsuarioResponse])
def buscar_usuarios(
    rol: Optional[str] = None,
    email: Optional[str] = None,
    db: Session = Depends(get_db)
):
    query = db.query(Usuario)
    if rol:
        query = query.filter(Usuario.rol == rol)
    if email:
        query = query.filter(Usuario.email.ilike(f"%{email}%"))
    usuarios = query.all()
    return usuarios

""" from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from database import SessionLocal, Usuario
from schemas import UsuarioResponse, UsuarioUpdateRol, UsuarioUpdateBloqueo, MensajeResponse

router = APIRouter()

# Dependencia para obtener la sesión de la base de datos.
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@router.get("/usuarios", response_model=list[UsuarioResponse])
def listar_usuarios(db: Session = Depends(get_db)):
    usuarios = db.query(Usuario).all()
    return usuarios

@router.put("/usuarios/{user_id}/rol", response_model=UsuarioResponse)
def actualizar_rol(user_id: int, update: UsuarioUpdateRol, db: Session = Depends(get_db)):
    usuario = db.query(Usuario).filter(Usuario.id == user_id).first()
    if not usuario:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Usuario no encontrado")
    usuario.rol = update.rol
    db.commit()
    db.refresh(usuario)
    return usuario

@router.put("/usuarios/{user_id}/bloqueo", response_model=UsuarioResponse)
def actualizar_bloqueo(user_id: int, update: UsuarioUpdateBloqueo, db: Session = Depends(get_db)):
    usuario = db.query(Usuario).filter(Usuario.id == user_id).first()
    if not usuario:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Usuario no encontrado")
    usuario.bloqueado = update.bloqueado
    db.commit()
    db.refresh(usuario)
    return usuario

@router.delete("/usuarios/{user_id}", response_model=MensajeResponse)
def eliminar_usuario(user_id: int, db: Session = Depends(get_db)):
    usuario = db.query(Usuario).filter(Usuario.id == user_id).first()
    if not usuario:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Usuario no encontrado")
    db.delete(usuario)
    db.commit()
    return {"mensaje": "Usuario eliminado con éxito"} """

----------------------------------------
# C:\americo\API\TaskGenie\routers\perfil.py
# Endpoints para ver y editar la información del perfil.
# routers/perfil.py
from fastapi import APIRouter

router = APIRouter()

@router.get("/")
def perfil():
    return {"mensaje": "Perfil del usuario"}


----------------------------------------
# C:\americo\API\TaskGenie\routers\tareas.py
# Endpoints para la gestión de tareas.
# routers/tareas.py
from fastapi import APIRouter

router = APIRouter()

@router.get("/")
def listar_tareas():
    return {"mensaje": "Listado de tareas"}


----------------------------------------
# C:\americo\API\TaskGenie\routers\usuarios.py
# C:\americo\API\TaskGenie\routers\usuarios.py

# C:\americo\API\TaskGenie\routers\usuarios.py

from fastapi import APIRouter, Depends, Form, HTTPException, status
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session
from database import SessionLocal, Usuario
from pydantic import BaseModel

router = APIRouter()

# Dependencia para obtener la sesión de la base de datos.
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# -------------------------------------------------------------------
# Esquema para registrar un usuario (para solicitudes JSON)
class UsuarioCreate(BaseModel):
    nombre: str
    apellido: str
    edad: int
    fecha_nacimiento: str  # Formato YYYY-MM-DD
    email: str
    clave: str  # Se espera plaintext (solo para práctica)
    
# Endpoint para registrar un usuario usando JSON.
@router.post("/registro/")
def registrar_usuario_json(usuario: UsuarioCreate, db: Session = Depends(get_db)):
    # Verificar si ya existe un usuario con el mismo email.
    existing_user = db.query(Usuario).filter(Usuario.email == usuario.email).first()
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Ya existe un usuario con ese email."
        )
    
    nuevo_usuario = Usuario(
        nombre=usuario.nombre,
        apellido=usuario.apellido,
        edad=usuario.edad,
        fecha_nacimiento=usuario.fecha_nacimiento,
        email=usuario.email,
        clave=usuario.clave
    )
    db.add(nuevo_usuario)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Ya existe un usuario con ese email."
        )
    db.refresh(nuevo_usuario)
    return {"mensaje": "Usuario registrado correctamente (JSON)", "id": nuevo_usuario.id}

# -------------------------------------------------------------------
# Endpoint para registrar un usuario usando datos de formulario.
@router.post("/registro_form")
def registrar_usuario_form(
    nombre: str = Form(...),
    apellido: str = Form(...),
    edad: int = Form(...),
    fecha_nacimiento: str = Form(...),  # Formato YYYY-MM-DD
    email: str = Form(...),
    clave: str = Form(...),
    db: Session = Depends(get_db)
):
    # Verificar si ya existe un usuario con ese email.
    existing_user = db.query(Usuario).filter(Usuario.email == email).first()
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Ya existe un usuario con ese email."
        )
    
    nuevo_usuario = Usuario(
        nombre=nombre,
        apellido=apellido,
        edad=edad,
        fecha_nacimiento=fecha_nacimiento,
        email=email,
        clave=clave
    )
    db.add(nuevo_usuario)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Ya existe un usuario con ese email."
        )
    db.refresh(nuevo_usuario)
    return {"mensaje": "Usuario registrado correctamente (Form)", "id": nuevo_usuario.id}

# -------------------------------------------------------------------
# Endpoint para recuperar la contraseña por email.
@router.get("/recuperar/{email}")
def recuperar_clave(email: str, db: Session = Depends(get_db)):
    usuario = db.query(Usuario).filter(Usuario.email == email).first()
    if usuario:
        return {"mensaje": f"La contraseña para {email} es: {usuario.clave}"}
    else:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Usuario no encontrado."
        )

# -------------------------------------------------------------------
# Esquema para login (para solicitudes JSON)
class UsuarioLogin(BaseModel):
    email: str
    clave: str

# Endpoint para login usando JSON.
@router.post("/login_json")
def login_json(usuario: UsuarioLogin, db: Session = Depends(get_db)):
    db_usuario = db.query(Usuario).filter(Usuario.email == usuario.email).first()
    if not db_usuario or db_usuario.clave != usuario.clave:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales inválidas."
        )
    return {"mensaje": "Login exitoso (JSON)", "usuario_id": db_usuario.id}

# -------------------------------------------------------------------
# Endpoint para login usando datos de formulario.
@router.post("/login_form")
def login_form(
    email: str = Form(...),
    clave: str = Form(...),
    db: Session = Depends(get_db)
):
    db_usuario = db.query(Usuario).filter(Usuario.email == email).first()
    if not db_usuario or db_usuario.clave != clave:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales inválidas."
        )
    return {"mensaje": "Login exitoso (Form)", "usuario_id": db_usuario.id}

----------------------------------------
# C:\americo\API\TaskGenie\routers\__init__.py

----------------------------------------
# C:\americo\API\TaskGenie\templates\dashboard_admin.html
<!-- Dashboard para administradores -->
<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>Dashboard Administrador - TaskGenie</title>
    <style>
      /* Estilos simples para organizar la interfaz */
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
      }
      nav {
        background-color: #333;
        color: #fff;
        padding: 10px;
      }
      nav ul {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
      }
      nav ul li {
        margin-right: 20px;
      }
      nav ul li a {
        color: #fff;
        text-decoration: none;
        cursor: pointer;
      }
      section {
        margin-top: 20px;
        display: none;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      table,
      th,
      td {
        border: 1px solid #ccc;
      }
      th,
      td {
        padding: 8px;
        text-align: left;
      }
      .visible {
        display: block;
      }
    </style>
  </head>
  <body>
    <!-- Menú de navegación -->
    <nav>
      <ul>
        <li><a onclick="showSection('listado')">Listado de Usuarios</a></li>
        <li><a onclick="showSection('detalle')">Detalle de Usuario</a></li>
        <li><a onclick="showSection('rol')">Actualizar Rol</a></li>
        <li><a onclick="showSection('bloqueo')">Actualizar Bloqueo</a></li>
        <li><a onclick="showSection('buscar')">Buscar Usuarios</a></li>
      </ul>
    </nav>

    <!-- Sección 1: Listar todos los usuarios -->
    <section id="listado">
      <h2>Listado de Usuarios</h2>
      <table id="tabla-usuarios">
        <thead>
          <tr>
            <th>ID</th>
            <th>Nombre</th>
            <th>Email</th>
            <th>Rol</th>
            <th>Bloqueado</th>
            <th>Acciones</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <script>
        // Función para cargar usuarios del endpoint /admin/usuarios
        function cargarUsuarios() {
          fetch("/admin/usuarios")
            .then((response) => response.json())
            .then((usuarios) => {
              const tbody = document.querySelector("#tabla-usuarios tbody");
              tbody.innerHTML = "";
              usuarios.forEach((usuario) => {
                const tr = document.createElement("tr");
                tr.innerHTML = `
                  <td>${usuario.id}</td>
                  <td>${usuario.nombre} ${usuario.apellido}</td>
                  <td>${usuario.email}</td>
                  <td>${usuario.rol}</td>
                  <td>${usuario.bloqueado ? "Sí" : "No"}</td>
                  <td>
                    <button onclick="verDetalle(${
                      usuario.id
                    })">Ver Detalle</button>
                    <button onclick="eliminarUsuario(${
                      usuario.id
                    })">Eliminar</button>
                  </td>
                `;
                tbody.appendChild(tr);
              });
            });
        }
      </script>
    </section>

    <!-- Sección 2: Detalle de Usuario -->
    <section id="detalle">
      <h2>Detalle de Usuario</h2>
      <form id="formDetalle" onsubmit="event.preventDefault(); verDetalle();">
        <label for="detalleId">ID del Usuario:</label>
        <input type="number" id="detalleId" required />
        <button type="submit">Ver Detalle</button>
      </form>
      <div id="detalle-usuario"></div>
      <script>
        function verDetalle(id) {
          // Permite usar el id del formulario o el pasado como argumento.
          let userId = id || document.getElementById("detalleId").value;
          fetch(`/admin/usuarios/${userId}`)
            .then((response) => response.json())
            .then((usuario) => {
              document.getElementById("detalle-usuario").innerHTML = `
                <p><strong>ID:</strong> ${usuario.id}</p>
                <p><strong>Nombre:</strong> ${usuario.nombre} ${
                usuario.apellido
              }</p>
                <p><strong>Email:</strong> ${usuario.email}</p>
                <p><strong>Rol:</strong> ${usuario.rol}</p>
                <p><strong>Bloqueado:</strong> ${
                  usuario.bloqueado ? "Sí" : "No"
                }</p>
              `;
            });
        }
      </script>
    </section>

    <!-- Sección 3: Actualizar Rol de Usuario -->
    <section id="rol">
      <h2>Actualizar Rol de Usuario</h2>
      <form id="formRol" onsubmit="event.preventDefault(); actualizarRol();">
        <label for="rolUserId">ID del Usuario:</label>
        <input type="number" id="rolUserId" required />
        <br />
        <label for="nuevoRol">Nuevo Rol:</label>
        <select id="nuevoRol" required>
          <option value="profesor">Profesor</option>
          <option value="alumno">Alumno</option>
          <option value="administrador">Administrador</option>
        </select>
        <br />
        <button type="submit">Actualizar Rol</button>
      </form>
      <script>
        function actualizarRol() {
          const userId = document.getElementById("rolUserId").value;
          const nuevoRol = document.getElementById("nuevoRol").value;
          fetch(`/admin/usuarios/${userId}/rol`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ rol: nuevoRol }),
          })
            .then((res) => res.json())
            .then((data) => {
              alert("Rol actualizado: " + data.rol);
            });
        }
      </script>
    </section>

    <!-- Sección 4: Actualizar Estado de Bloqueo -->
    <section id="bloqueo">
      <h2>Actualizar Estado de Bloqueo</h2>
      <form
        id="formBloqueo"
        onsubmit="event.preventDefault(); actualizarBloqueo();"
      >
        <label for="bloqUserId">ID del Usuario:</label>
        <input type="number" id="bloqUserId" required />
        <br />
        <label for="estadoBloqueo">Bloquear Usuario:</label>
        <select id="estadoBloqueo" required>
          <option value="true">Sí</option>
          <option value="false" selected>No</option>
        </select>
        <br />
        <button type="submit">Actualizar Bloqueo</button>
      </form>
      <script>
        function actualizarBloqueo() {
          const userId = document.getElementById("bloqUserId").value;
          const bloqueado =
            document.getElementById("estadoBloqueo").value === "true";
          fetch(`/admin/usuarios/${userId}/bloqueo`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ bloqueado }),
          })
            .then((res) => res.json())
            .then((data) => {
              alert(
                "Estado de bloqueo actualizado: " +
                  (data.bloqueado ? "Bloqueado" : "No bloqueado")
              );
            });
        }
      </script>
    </section>

    <!-- Sección 5: Buscar Usuarios por Filtro -->
    <section id="buscar">
      <h2>Buscar Usuarios</h2>
      <form
        id="formBusqueda"
        onsubmit="event.preventDefault(); buscarUsuarios();"
      >
        <label for="filtroRol">Rol:</label>
        <select id="filtroRol">
          <option value="">Todos</option>
          <option value="profesor">Profesor</option>
          <option value="alumno">Alumno</option>
          <option value="administrador">Administrador</option>
        </select>
        <label for="filtroEmail">Email:</label>
        <input type="text" id="filtroEmail" placeholder="Buscar por email" />
        <button type="submit">Buscar</button>
      </form>
      <div id="resultadosBusqueda"></div>
      <script>
        function buscarUsuarios() {
          const rol = document.getElementById("filtroRol").value;
          const email = document.getElementById("filtroEmail").value;
          let url = "/admin/usuarios/search?";
          if (rol) url += "rol=" + encodeURIComponent(rol) + "&";
          if (email) url += "email=" + encodeURIComponent(email);
          fetch(url)
            .then((response) => response.json())
            .then((usuarios) => {
              let html = "<ul>";
              usuarios.forEach((usuario) => {
                html += `<li>ID: ${usuario.id} - ${usuario.nombre} ${usuario.apellido} (${usuario.rol})</li>`;
              });
              html += "</ul>";
              document.getElementById("resultadosBusqueda").innerHTML = html;
            });
        }
      </script>
    </section>

    <!-- Script de control de navegación -->
    <script>
      // Función para ocultar todas las secciones y mostrar la solicitada
      function showSection(id) {
        const sections = document.querySelectorAll("section");
        sections.forEach((section) => (section.style.display = "none"));
        document.getElementById(id).style.display = "block";

        // Acciones adicionales: por ejemplo, si se carga el listado, recargar usuarios.
        if (id === "listado") {
          cargarUsuarios();
        }
      }
      // Mostrar por defecto la sección de listado al cargar
      window.onload = function () {
        showSection("listado");
      };

      // Función para eliminar un usuario (utilizada en listado)
      function eliminarUsuario(userId) {
        if (confirm("¿Estás seguro de eliminar este usuario?")) {
          fetch(`/admin/usuarios/${userId}`, { method: "DELETE" })
            .then((response) => response.json())
            .then((data) => {
              alert(data.mensaje);
              cargarUsuarios();
            });
        }
      }
    </script>
  </body>
</html>

----------------------------------------
# C:\americo\API\TaskGenie\templates\dashboard_alumno.html
<!-- Dashboard para alumnos -->

----------------------------------------
# C:\americo\API\TaskGenie\templates\dashboard_profesor.html
<!-- Dashboard para profesores -->

----------------------------------------
# C:\americo\API\TaskGenie\templates\errores.html
<!-- html para manejo de errores -->
<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>Error 404 - No Encontrado</title>
  </head>
  <body>
    <h1>Error 404</h1>
    <p>{{ mensaje }}</p>
    <a href="/">Volver al inicio</a>
  </body>
</html>

----------------------------------------
# C:\americo\API\TaskGenie\templates\dashboard.html
<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>Dashboard</title>
  </head>
  <body>
    <h1>¡Bienvenido al Dashboard!</h1>
    <p>Aquí se muestran las funcionalidades para el usuario autenticado.</p>
    <a href="/">Volver al inicio</a>
  </body>
</html>

----------------------------------------
# C:\americo\API\TaskGenie\templates\index.html
<!-- index.html - Página de inicio con formulario de login -->
<!-- templates/index.html - Página de inicio con formulario de login -->
<!-- templates/index.html -->
<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>TaskGenie - Login</title>
  </head>
  <body>
    <h1>Login usando Form</h1>
    {% if error %}
    <p style="color: red">{{ error }}</p>
    {% endif %}
    <form action="/login_form" method="post">
      <label>Email:</label>
      <input type="text" name="email" required />
      <br />
      <label>Clave:</label>
      <input type="password" name="clave" required />
      <br />
      <button type="submit">Ingresar</button>
    </form>
    <p>¿No tienes una cuenta? <a href="/registro">Regístrate aquí</a></p>
  </body>
</html>

----------------------------------------
# C:\americo\API\TaskGenie\templates\login.html
<!-- Vista de login -->

----------------------------------------
# C:\americo\API\TaskGenie\templates\registro.html
<!-- Formulario de registro -->
<!-- templates/registro.html -->
<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>Registro de Usuario - TaskGenie</title>
  </head>
  <body>
    <h1>Registro de Usuario</h1>
    {% if error %}
    <p style="color: red">{{ error }}</p>
    {% endif %}
    <form action="/registro_form" method="post">
      <label for="nombre">Nombre:</label>
      <input type="text" id="nombre" name="nombre" required />
      <br />
      <label for="apellido">Apellido:</label>
      <input type="text" id="apellido" name="apellido" required />
      <br />
      <label for="edad">Edad:</label>
      <input type="number" id="edad" name="edad" required />
      <br />
      <label for="fecha_nacimiento">Fecha de Nacimiento (YYYY-MM-DD):</label>
      <input
        type="text"
        id="fecha_nacimiento"
        name="fecha_nacimiento"
        placeholder="YYYY-MM-DD"
        required
      />
      <br />
      <label for="email">Email:</label>
      <input type="email" id="email" name="email" required />
      <br />
      <label for="rol">Tipo usuario:</label>
      <select id="rol" name="rol" required>
        <option value="profesor">Profesor</option>
        <option value="alumno">Alumno</option>
        <option value="administrador">Administrador</option>
      </select>
      <br />
      <label for="clave">Clave:</label>
      <input type="password" id="clave" name="clave" required />
      <br />
      <button type="submit">Registrarse</button>
    </form>
    <p><a href="/">Volver al inicio</a></p>
  </body>
</html>

----------------------------------------
# C:\americo\API\TaskGenie\services\auth_service.py
# auth_service.py
# este archivo contiene la lógica de negocio relacionada con la autenticación y el registro de usuarios.
from sqlalchemy.exc import IntegrityError
from database import Usuario

def registrar_usuario(db, nombre, apellido, edad, fecha_nacimiento, email, rol, clave ):
    # Aquí se podría aplicar hash a la contraseña (por ejemplo, usando bcrypt)
    nuevo_usuario = Usuario(
        nombre=nombre,
        apellido=apellido,
        edad=edad,
        fecha_nacimiento=fecha_nacimiento,
        email=email,
        rol=rol,
        clave=clave  # Reemplazar con hash_password(clave) en producción
        
    )
    db.add(nuevo_usuario)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise ValueError("Ya existe un usuario con ese email.")
    db.refresh(nuevo_usuario)
    return nuevo_usuario

def autenticar_usuario(db, email, clave):
    usuario = db.query(Usuario).filter(Usuario.email == email).first()
    if usuario and usuario.clave == clave:  # En producción comparar contra el hash
        return usuario
    return None


